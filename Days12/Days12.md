
# 1. 클래스를 만드는 방법

클래스는 프로퍼티와 메서드가 있는 새로운 데이터자료형을 만든다는 의미에서 구조체와 비슷하지만 상속이라는 새로운 기능을 사용할 수 있습니다.

> 클래스와 구조체의 공통점

1.  생성하고 이름을 지정할 수 있습니다.
2.  프로퍼티옵저버 및 접근제어자를 사용할 수 있습니다.
3.  커스텀이니셜라이저를 생성할 수 있습니다.

----------

> 클래스와 구조체의 차이점

1.  클래스는 상속이 가능합니다. (하나의 클래스가 다른 클래스를 기반으로 시작점으로 사용할 수 있고, 일부 메서드를 재정의할 수 있습니다)
2.  클래스는 멤버별이니셜라이즈(memberwise initializer)를 자동으로 생성하지 않습니다.
3.  클래스의 인스턴스를 복사하면 두 복사본이 동일한 데이터를 공유합니다. (구조체는 값타입, 클래스는 참조타입)
4.  클래스의 인스턴스가 메모리에서 해제될 때 deinitializer 기능을 사용할 수 있습니다.
5.  클래스를 상수로 만들어도 변수인 프로퍼티는 변경할 수 있습니다. (mutating키워드 사용 하지않아도 됩니다.)

구조체는 `struct` 키워드를 사용하여 생성했지만, 클래스는 `class` 키워드를 사용하여 생성합니다.

# 2. 클래스의 상속을 사용하는 방법

스위프트에서는 기존 클래스를 기반으로 새로운 클래스를 생성할 수 있습니다. 기준이 되는 기존 클래스를 (부모클래스 및 super클래스)라고 하고 새로 생성된 클래스를 (자식클래스 및 sub클래스)라고 부릅니다.

자식클래스가 부모클래스의 메서드를 변경하려는 경우 `override` 키워드를 통해 메서드를 재정의할 수 있습니다.

클래스가 상속을 지원하지 않도록 하기 위해서는 `final` 키워드를 통해 해당 클래스의 상속을 제한할 수 있습니다.

# 3. 클래스의 이니셜라이저를 추가하는 방법

자식클래스에 커스텀이니셜라이저가 있는 경우 자식클래스의 설정을 모두 마친 후 부모클래스의 프로퍼티가 있는 경우, 항상 부모클래스의 이니셜라이저를 호출해야합니다.

⚠️ 자식클래스의 이니셜라이저가 없으면 자동으로 부모클래스의 이니셜라이저를 상속합니다.

# 4. 클래스 = 참조타입

스위프트에서 클래스 인스턴스의 모든 복사본은 동일한 데이터를 공유합니다.

만약, 동일한 데이터를 공유하고 싶지 않은 경우, deep copy를 사용합니다.

> deep copy 예시

```swift
class UniqueUser {
    var username = "Anonymous"

    func copy() -> User {
        let user = User()
        user.username = username
        return user
    }
}

var uniqueUser1 = UniqueUser()
var uniqueUser2 = uniqueUser1.copy()

```

# 5. 클래스의 deinitializer 사용하는 방법

클래스의 인스턴스가 메모리에서 해제될 때 deinitializer가 호출됩니다.

`deinit` 키워드를 사용하고 매개변수나 데이터를 반환하지 않습니다. 직접 호출하는 방식이 아니라 시스템에 의해 호출됩니다.

# 6. 클래스내의 변수프로퍼티를 사용하는 방법

1.  상수 인스턴스, 상수 프로퍼티 – 항상 동일한 프로퍼티값을 가진 동일한 인스턴스를 가리킵니다.
2.  상수 인스턴스, 가변 프로퍼티 – 항상 동일한 인스턴스를 가리키지만 프로퍼티값은 변경될 수 있습니다.
3.  가변 인스턴스, 상수 프로퍼티 – 다른 인스턴스를 가리킬 수 있지만 프로퍼티값은 절대 변경되지 않습니다.
4.  변수 인스턴스, 변수 프로퍼티 – 다른 인스턴스를 가리킬 수 있으며, 해당 인스턴스는 프로퍼티값을 변경할 수 있습니다.
